{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"polyply","text":""},{"location":"#functionality","title":"Functionality","text":"<p>Polyply is a python suite designed to facilitate the generation of input files and system coordinates for simulating (bio)macromolecules such as synthetic polymers or polysaccharides. Input files can be generated either from user specified building blocks or by using the polymers available in the library. The library currently includes polymer definitions for the GROMOS (2016H66 &amp; 54A6), OPLS, Parmbsc1, and Martini (2 &amp; 3) force-fields. Coordinates are generated by a multiscale random-walk protocol that is able to generate condensed phase systems at target density, as well as more heterogeneous systems such as aqueous two phase systems. In addition, polyply allows to tailor initial chain conformations by providing a build file. For example, the persistence length can be used to control the initial chain dimensions. The quick start section in the wiki gives an overview of the most important commands. In addition, tutorials are provided for more in-depth information on how to use the program. Tutorials include how to generate Martini polymer systems and write input files. More details on the algorithm and verification can be found in the publication.</p> <p>Make sure to always verify the results and give appropriate credit to the developers of the force-field, molecule parameters and this program.</p>"},{"location":"#quick-references","title":"Quick references","text":"<p>Installation Guide\\ FAQs\\ Current Polyply Polymer Library\\ Submissions to Martini Polymer Library\\ Tutorial: Martini Polymers\\ Tutorial: GROMOS Polymers\\ Tutorial: PEGylated lipid bilayers\\ Tutorial: Single-stranded DNA</p>"},{"location":"#news","title":"News","text":"<ul> <li>(Feb 8, 22') Featured Research Article in Nature Communcations. Our article on the polyply software suite is now featured on the Editors' Highlights for Structural biology, biochemistry and biophysics in Nature Communications. The Editors\u2019 Highlights pages aims to showcase the 50 best papers recently published in an area. The development team is beyond happy to receive this honor.</li> <li>(May 23, 22') Fighting Cancer with polyply. Dane et al. used polyply to setup simulations of vesicles and lipid nanodiscs (LNDs) containing PEGylated lipids, which are used as nanocarriers for cancer therapeutics. They find that LNDs are more effective in delivery likely due to their higher flexibility.  Check it out in Nature Materials.</li> <li>(Jan 18, 23') Towards whole cell simulations with polyply. In a perspective on whole-cell simulations using the Martini force field, Stevens et al. utilize polyply to construct the full 0.5 Mio bp chromosome of the Syn3A minimal cell. This impressive task is a good example of the power of the upcoming DNA implementation into polyply and the role of polyply in the Martini Ecosystem.</li> </ul>"},{"location":"#contributions-support","title":"Contributions &amp; Support","text":"<p>We are happy to accept submissions of polymer parameters to the polyply library. To submit parameters simply open an issue. More details on submitting parameters can be found here. The code development of polyply is done on github. Contributions are welcome as bug reports and pull requests from everyone. We are also happy to discuss any of your projects or hear about how you used polyply in your research project. Let us know on the discussions board or by tweeting with #CG_MARTINI or #polyplyMD.</p>"},{"location":"#citation","title":"Citation","text":"<pre><code>@article{Grunewald2022Polyply,\n  title={Polyply; a python suite for facilitating simulations of (bio-) macromolecules and nanomaterials},\n  author={Gr{\\\"u}newald, Fabian and Alessandri, Riccardo and Kroon, Peter C and\n      Monticelli, Luca and Souza, Paulo CT and Marrink, Siewert J},\n  journal={Nature Communications},\n  volume={13},\n  pages={68},\n  doi={https://doi.org/10.1038/s41467-021-27627-4},\n  year={2022}\n}\n</code></pre>"},{"location":"#license","title":"License","text":"<p>Polyply is distributed under the Apache 2.0 license.</p> <pre><code>Copyright 2020 University of Groningen\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre> <p>The full text of the license is available in the source repository.</p>"},{"location":"1_organize/","title":"polyply organization","text":"<p>Polyply is a software suite/library that consists of three separate programs - <code>polyply gen_params</code> for parameter file generation, - <code>polyply gen_coords</code> for coordinate file generation - <code>polyply gen_seq</code> which is an auxiliary program for generation sequences that can be read by the parameter generation program.</p> <p>Polyply Tutorial - Early Life</p>"},{"location":"build_system/","title":"build_system","text":""},{"location":"build_system/#polyply.src.build_system","title":"<code>polyply.src.build_system</code>","text":"<p>Processor for building systems with more than one molecule</p>"},{"location":"build_system/#polyply.src.build_system.BuildSystem","title":"<code>BuildSystem</code>","text":"<p>Compose a system of molecules according to the definitions in the topology file.</p> <p>This class when run for a system or a molecule calls the random-walk processor to generate the coordinates for a single moleccule. In contrast to the random-walk processor this class handles all system related accouting matters such as starting points, box-dimensions and existing molecules and so forth.</p>"},{"location":"build_system/#polyply.src.build_system.BuildSystem--parameters","title":"Parameters:","text":"<p>topology: :class:<code>polyply.src.topology</code> density: float     the system density start_dict: dict     a dictionary associating ... grid_spacing: flaot     the distance between grid points grid: np.ndarray     a grid defining grid points this argument     overwrides generation of the grid using     the grid-spacing maxiter: int     maximum number of tries to genrate a single     molecule box: np.ndarray[3,1]     box size, this overwrites generation of the box     by the density argument ignore: list[str]     list of molecule names to ignore when building **kwargs:     all passed down to random-walk</p> Source code in <code>polyply/src/build_system.py</code> <pre><code>class BuildSystem():\n\"\"\"\n    Compose a system of molecules according\n    to the definitions in the topology file.\n    This class when run for a system or a molecule\n    calls the random-walk processor to generate the\n    coordinates for a single moleccule. In contrast\n    to the random-walk processor this class handles\n    all system related accouting matters such as\n    starting points, box-dimensions and existing\n    molecules and so forth.\n    Parameters:\n    -----------\n    topology: :class:`polyply.src.topology`\n    density: float\n        the system density\n    start_dict: dict\n        a dictionary associating ...\n    grid_spacing: flaot\n        the distance between grid points\n    grid: np.ndarray\n        a grid defining grid points this argument\n        overwrides generation of the grid using\n        the grid-spacing\n    maxiter: int\n        maximum number of tries to genrate a single\n        molecule\n    box: np.ndarray[3,1]\n        box size, this overwrites generation of the box\n        by the density argument\n    ignore: list[str]\n        list of molecule names to ignore when building\n    **kwargs:\n        all passed down to random-walk\n    \"\"\"\ndef __init__(self,\ntopology,\ndensity,\nstart_dict,\ngrid_spacing=0.2,\nmaxiter=800,\nbox=None,\nignore=[],\ngrid=None,\ncycles=[],\n**kwargs):\nself.topology = topology\nself.density = density\nself.grid_spacing = grid_spacing\nself.maxiter = maxiter\nself.ignore = ignore\nself.box_grid = grid\nself.box = box\nself.start_dict = start_dict\nself.molecules = []\nself.nonbond_matrix = None\nself.cycles = cycles\n# first we check if **kwargs are actually in random-walk\nvalid_kwargs = inspect.getfullargspec(RandomWalk).args\nfor kwarg in kwargs:\nif kwarg not in valid_kwargs:\nmsg = (\"Keyword argument {} is not valid for the \"\n\"RandomWalk processor class. \")\nraise TypeError(msg.format(kwarg))\nself.rwargs = kwargs\n# set the box if a box is given\n# we use type comparison because box is an array\nif not isinstance(self.box, type(None)):\nself.box = box\n# if box is not given but density compute it from density\nelse:\nbox_dim = round(_compute_box_size(topology, self.density), 5)\nself.box = np.array([box_dim, box_dim, box_dim])\n# intialize the grid if there is none given\nif isinstance(self.box_grid, type(None)):\nself.box_grid = np.mgrid[0:self.box[0]:self.grid_spacing,\n0:self.box[1]:self.grid_spacing,\n0:self.box[2]:self.grid_spacing].reshape(3, -1).T\n# this should be done elsewhere\ntopology.box = (self.box[0], self.box[1], self.box[2])\ndef _handle_random_walk(self, molecule, mol_idx, vector_sphere):\nstep_count = 0\nwhile True:\nstart_idx = np.random.randint(len(self.box_grid))\nstart = self.box_grid[start_idx]\nprocessor = RandomWalk(mol_idx,\nself.nonbond_matrix,\nstart=start,\nmaxdim=self.box,\nvector_sphere=vector_sphere,\nstart_node=self.start_dict[mol_idx],\n**self.rwargs)\nprocessor.run_molecule(molecule)\nif processor.success:\nreturn True, processor.nonbond_matrix\nelif step_count == self.maxiter:\nprocessor.nonbond_matrix.remove_positions(mol_idx, molecule.nodes)\nreturn False, processor.nonbond_matrix\nelse:\nstep_count += 1\nself.nonbond_matrix.remove_positions(mol_idx, molecule.nodes)\ndef _compose_system(self, molecules):\n\"\"\"\n        Place the molecules of the system into a box\n        and optimize positions to meet density.\n        Parameters\n        ----------\n        topology:  :class:`vermouth.system`\n        density: foat\n           density of the system in kg/cm3\n        Returns\n        --------\n        system\n        \"\"\"\nmol_idx = 0\npbar = tqdm(total=len(molecules))\nmol_tot = len(molecules)\nvector_sphere = norm_sphere(5000)\nwhile mol_idx &lt; mol_tot:\nmolecule = molecules[mol_idx]\nif all([\"position\" in molecule.nodes[node] for node in molecule.nodes]):\nmol_idx += 1\npbar.update(1)\ncontinue\nsuccess, new_nonbond_matrix = self._handle_random_walk(molecule,\nmol_idx,\nvector_sphere)\nif success:\nself.nonbond_matrix = new_nonbond_matrix\nself.nonbond_matrix.concatenate_trees()\nmol_idx += 1\npbar.update(1)\npbar.close()\nself.nonbond_matrix.update_positions_in_molecules(molecules)\ndef run_system(self, molecules):\n\"\"\"\n        Compose a system according to a the system\n        specifications and a density value.\n        \"\"\"\n# filter all molecules that should be ignored during the building process\nself.molecules = list(_filter_by_molname(self.topology.molecules, self.ignore))\n# generate the nonbonded matrix wrapping all information about molecular\n# interactions\nself.nonbond_matrix = NonBondEngine.from_topology(self.molecules, self.topology, self.box)\n# apply sampling of persistence length\nsample_end_to_end_distances(self.topology, self.nonbond_matrix)\n# set any other distance and/or position restraints\nset_restraints(self.topology, self.nonbond_matrix)\nself._compose_system(self.topology.molecules)\nreturn molecules\n</code></pre>"},{"location":"build_system/#polyply.src.build_system.BuildSystem.run_system","title":"<code>run_system(molecules)</code>","text":"<p>Compose a system according to a the system specifications and a density value.</p> Source code in <code>polyply/src/build_system.py</code> <pre><code>def run_system(self, molecules):\n\"\"\"\n    Compose a system according to a the system\n    specifications and a density value.\n    \"\"\"\n# filter all molecules that should be ignored during the building process\nself.molecules = list(_filter_by_molname(self.topology.molecules, self.ignore))\n# generate the nonbonded matrix wrapping all information about molecular\n# interactions\nself.nonbond_matrix = NonBondEngine.from_topology(self.molecules, self.topology, self.box)\n# apply sampling of persistence length\nsample_end_to_end_distances(self.topology, self.nonbond_matrix)\n# set any other distance and/or position restraints\nset_restraints(self.topology, self.nonbond_matrix)\nself._compose_system(self.topology.molecules)\nreturn molecules\n</code></pre>"}]}